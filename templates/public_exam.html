<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>{{ spec.title }}</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='ui.css') }}" />
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [["$", "$"], ["\\(", "\\)"]],
          displayMath: [["$$", "$$"], ["\\[", "\\]"]],
        },
        options: { skipHtmlTags: ["script", "noscript", "style", "textarea", "pre", "code"] },
      };
    </script>
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
      .md { white-space: normal; }
      .md img { max-width: 100%; height: auto; border-radius: 10px; display:block; margin: 10px 0; }

      .exam-meta-title { display:flex; align-items: baseline; gap: 10px; flex-wrap: wrap; justify-content: center; }
      .exam-meta-title h2 { margin: 0; font-size: 18px; }
      .exam-meta-desc { max-width: 920px; margin: 6px auto 0; color: var(--muted); font-size: 13px; line-height: 1.6; text-align: center; }
      .exam-meta-stats { margin-top: 10px; display:flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid rgba(15, 23, 42, 0.10);
        background: rgba(255, 255, 255, 0.86);
        font-weight: 800;
        font-size: 12px;
        color: rgba(15, 23, 42, 0.86);
        white-space: nowrap;
      }
    </style>
  </head>
  <body>
    <header class="topbar">
      <div class="container topbar-inner">
        <div class="brand" aria-label="Servforce Quiz">
          <span class="brand-badge" aria-hidden="true"></span>
          <span>Servforce Quiz</span>
        </div>
        <div class="nav" aria-label="候选人端">
          <span class="nav-link active">在线作答</span>
        </div>
        <div class="flex">
          <span class="nav-link" style="cursor:default;">剩余：<b id="remain" data-seconds="{{ remaining_seconds }}">{{ remaining_seconds }}</b></span>
          <span class="nav-link" id="submitHint" style="cursor:default; color: rgba(220,38,38,.9);"></span>
          <form method="post" action="/api/public/submit/{{ token }}" style="margin:0;">
            <button id="submitBtn" class="btn btn-primary" type="submit">提交试卷</button>
          </form>
        </div>
      </div>
    </header>

    <main class="container page">
      {% for m in get_flashed_messages() %}
      <div class="flash error">{{ m }}</div>
      {% endfor %}

      <div class="surface" role="region" aria-label="试卷">
        <section class="section">
          <div class="exam-meta-title">
            <h2>{{ spec.title }}</h2>
            <span class="muted">({{ exam_key }})</span>
          </div>
          {% if spec.description %}
            <div class="exam-meta-desc">{{ spec.description }}</div>
          {% endif %}
          <div class="exam-meta-stats" aria-label="试卷统计">
            <span class="pill">题目数：{{ (exam_stats or {}).get('total_questions', 0) }}</span>
            <span class="pill">总分：{{ (exam_stats or {}).get('total_points', 0) }} 分</span>
            {% for t, c in ((exam_stats or {}).get('counts_by_type', {}) or {}).items() %}
              {% set pts = ((exam_stats or {}).get('points_by_type', {}) or {}).get(t, 0) %}
              <span class="pill">{{ (type_label_map or {}).get(t, t) }}：{{ c }} 题 / {{ pts }} 分</span>
            {% endfor %}
          </div>
        </section>

        <section class="section">
          <form id="examForm">
            <input type="hidden" name="token" value="{{ token }}" />
            {% for q in spec.questions %}
              <div class="exam-q" data-qid="{{ q.qid }}">
                <div class="exam-q__inner">
                  <div class="exam-q__head">
                    <div class="exam-q__head-left">
                      <span class="exam-q__qid">{{ q.label or q.qid }}</span>
                      {% set type_label_map = {'single':'单选','multiple':'多选','short':'简答','unknown':'其他'} %}
                      <span class="exam-tag type">{{ type_label_map.get(q.type, q.type) }}</span>
                    </div>
                    <span class="exam-tag points">{{ q.max_points }}分</span>
                  </div>

                  <div class="exam-q__body">
                    <div class="md">{{ q.stem_md | md }}</div>

                    {% if q.type == 'single' %}
                      <div class="exam-options" aria-label="选项">
                        {% for o in q.options %}
                          <label class="exam-opt">
                            <input type="radio" name="{{ q.qid }}" value="{{ o.key }}" {% if answers.get(q.qid)==o.key %}checked{% endif %} />
                            <div class="exam-opt__box">
                              <div class="exam-opt__key">{{ o.key }}</div>
                              <div class="exam-opt__text">{{ o.text }}</div>
                            </div>
                          </label>
                        {% endfor %}
                      </div>
                    {% elif q.type == 'multiple' %}
                      {% set chosen = answers.get(q.qid) or [] %}
                      <div class="exam-options" aria-label="选项">
                        {% for o in q.options %}
                          <label class="exam-opt">
                            <input type="checkbox" name="{{ q.qid }}[]" value="{{ o.key }}" {% if o.key in chosen %}checked{% endif %} />
                            <div class="exam-opt__box">
                              <div class="exam-opt__key">{{ o.key }}</div>
                              <div class="exam-opt__text">{{ o.text }}</div>
                            </div>
                          </label>
                        {% endfor %}
                      </div>
                    {% else %}
                      <textarea name="{{ q.qid }}" class="exam-short" placeholder="请输入你的回答">{{ answers.get(q.qid) or "" }}</textarea>
                    {% endif %}
                  </div>
                </div>
              </div>
            {% endfor %}
          </form>
        </section>
      </div>
    </main>

    <script>
      const remainEl = document.getElementById('remain');
      let remain = parseInt(remainEl.dataset.seconds || remainEl.textContent || '0', 10);
      const timeLimit = parseInt("{{ time_limit_seconds }}", 10) || 0;
      const minSubmit = parseInt("{{ min_submit_seconds }}", 10) || 0;

      const submitBtn = document.getElementById('submitBtn');
      const submitHint = document.getElementById('submitHint');

      function pad2(n) { return String(n).padStart(2, '0'); }
      function formatSeconds(s) {
        const sec = Math.max(0, parseInt(s || '0', 10));
        const h = Math.floor(sec / 3600);
        const m = Math.floor((sec % 3600) / 60);
        const r = sec % 60;
        return `${pad2(h)}:${pad2(m)}:${pad2(r)}`;
      }

      function updateRemain() {
        remainEl.textContent = formatSeconds(remain);
      }

      function updateSubmitState() {
        if (!submitBtn) return;
        const elapsed = timeLimit ? Math.max(0, timeLimit - remain) : 0;
        const canSubmit = minSubmit <= 0 || remain <= 0 || elapsed >= minSubmit;
        submitBtn.disabled = !canSubmit;
        if (!submitHint) return;
        if (canSubmit) {
          submitHint.textContent = '';
          return;
        }
        const wait = Math.max(0, minSubmit - elapsed);
        const mins = Math.ceil(minSubmit / 60);
        submitHint.textContent = `需考试开始后满 ${mins} 分钟才可交卷（还需等待 ${formatSeconds(wait)}）`;
      }

      updateRemain();
      updateSubmitState();

      setInterval(() => {
        if (remain <= 0) return;
        remain -= 1;
        updateRemain();
        updateSubmitState();
        if (remain === 0) {
          const f = document.querySelector('form[action^="/api/public/submit"]');
          if (!f) return;
          if (typeof f.requestSubmit === 'function') {
            f.requestSubmit();
          } else if (submitBtn) {
            submitBtn.click();
          } else {
            f.submit();
          }
        }
      }, 1000);

      function saveAnswer(formData, token, qid) {
        formData.append('question_id', qid);
        fetch(`/api/public/answers/${token}`, { method: 'POST', body: formData }).catch(() => {});
      }

      function collectAnswerForQBox(qBox) {
        const qid = qBox.dataset.qid;
        const fd = new FormData();
        const textarea = qBox.querySelector('textarea');
        const radios = qBox.querySelectorAll('input[type="radio"]');
        const checks = qBox.querySelectorAll('input[type="checkbox"]');
        if (checks && checks.length) {
          const checked = qBox.querySelectorAll('input[type="checkbox"]:checked');
          checked.forEach(x => fd.append('answer[]', x.value));
        } else if (radios && radios.length) {
          const chosen = qBox.querySelector('input[type="radio"]:checked');
          if (chosen) fd.append('answer', chosen.value);
        } else if (textarea) {
          fd.append('answer', textarea.value || '');
        }
        return { qid, fd };
      }

      const examFormEl = document.getElementById('examForm');

      examFormEl.addEventListener('change', (e) => {
        const qBox = e.target.closest('.exam-q');
        if (!qBox) return;
        const token = "{{ token }}";
        const { qid, fd } = collectAnswerForQBox(qBox);
        saveAnswer(fd, token, qid);
      });

      // Also auto-save textarea while typing (avoid losing content when user submits too early).
      const debounceByQid = new Map();
      examFormEl.addEventListener('input', (e) => {
        if (!e.target || e.target.tagName !== 'TEXTAREA') return;
        const qBox = e.target.closest('.exam-q');
        if (!qBox) return;
        const token = "{{ token }}";
        const { qid } = collectAnswerForQBox(qBox);
        const prev = debounceByQid.get(qid);
        if (prev) clearTimeout(prev);
        const t = setTimeout(() => {
          const { fd } = collectAnswerForQBox(qBox);
          saveAnswer(fd, token, qid);
        }, 350);
        debounceByQid.set(qid, t);
      });

      function collectAllAnswersObject() {
        const qBoxes = Array.from(document.querySelectorAll('.exam-q[data-qid]'));
        const out = {};
        for (const qBox of qBoxes) {
          const qid = qBox.dataset.qid;
          const textarea = qBox.querySelector('textarea');
          const radios = qBox.querySelectorAll('input[type="radio"]');
          const checks = qBox.querySelectorAll('input[type="checkbox"]');
          if (checks && checks.length) {
            const checked = Array.from(qBox.querySelectorAll('input[type="checkbox"]:checked')).map(x => x.value);
            if (checked.length) out[qid] = checked;
          } else if (radios && radios.length) {
            const chosen = qBox.querySelector('input[type="radio"]:checked');
            if (chosen) out[qid] = chosen.value;
          } else if (textarea) {
            const v = textarea.value || '';
            if (v.trim() !== '') out[qid] = v;
          }
        }
        return out;
      }

      async function saveAllAnswersBulk() {
        const token = "{{ token }}";
        const answers = collectAllAnswersObject();
        try {
          await fetch(`/api/public/answers_bulk/${token}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ answers }),
          });
        } catch (_e) {}
      }

      const submitForm = document.querySelector('form[action^="/api/public/submit"]');
      let submitting = false;
      if (submitForm) {
        submitForm.addEventListener('submit', async (e) => {
          if (submitting) return;
          e.preventDefault();

          // Not reached min submit time: only show hint, do not refresh, keep answers.
          const elapsed = timeLimit ? Math.max(0, timeLimit - remain) : 0;
          const canSubmit = minSubmit <= 0 || remain <= 0 || elapsed >= minSubmit;
          if (!canSubmit) {
            updateSubmitState();
            return;
          }

          // Ensure latest answers are persisted before submitting.
          submitting = true;
          try {
            await saveAllAnswersBulk();
          } finally {
            // Use native submit() to bypass this handler.
            submitForm.submit();
          }
        });
      }
    </script>
  </body>
</html>
