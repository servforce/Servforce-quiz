<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>{{ spec.title }}</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='ui.css') }}" />
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [["$", "$"], ["\\(", "\\)"]],
          displayMath: [["$$", "$$"], ["\\[", "\\]"]],
        },
        options: { skipHtmlTags: ["script", "noscript", "style", "textarea", "pre", "code"] },
      };
    </script>
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
      .md { white-space: normal; }
      .md img { max-width: 100%; height: auto; border-radius: 10px; display:block; margin: 10px 0; }

      .exam-meta-title { display:flex; align-items: baseline; gap: 10px; flex-wrap: wrap; justify-content: center; }
      .exam-meta-title h2 {
        margin: 0;
        font-size: 26px;
        font-weight: 950;
        letter-spacing: -0.2px;
        line-height: 1.2;
      }
      .exam-meta-title .muted { font-size: 14px; }
      .exam-meta-desc { max-width: 920px; margin: 6px auto 0; color: var(--muted); font-size: 13px; line-height: 1.6; text-align: center; }
      .exam-meta-stats { margin-top: 10px; display:flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
      .exam-surface { position: relative; }
      .exam-submit-corner {
        position: absolute;
        right: 16px;
        top: 16px;
        z-index: 5;
        display: grid;
        justify-items: end;
        gap: 6px;
      }
      .exam-submit-corner .btn {
        padding: 12px 18px;
        border-radius: 14px;
        font-size: 16px;
        font-weight: 900;
        min-width: 120px;
      }
      .exam-submit-hint {
        color: rgba(220, 38, 38, 0.92);
        font-weight: 800;
        font-size: 12px;
        line-height: 1.35;
        text-align: right;
        max-width: 260px;
      }

      /* Floating time card (fixed to viewport, aligned to exam surface right edge). */
      .floating-time-card {
        position: fixed;
        top: 120px; /* below topbar */
        /* Default: align with exam surface left padding. */
        left: max(18px, calc((100vw - 1080px) / 2 + 18px));
        z-index: 12;
        width: 260px;
        max-width: calc(100vw - 36px);
        padding: 10px 12px;
        border-radius: 18px;
        border: 1px solid rgba(15, 23, 42, 0.12);
        background: rgba(255, 255, 255, 0.94);
        box-shadow: 0 22px 56px rgba(2, 6, 23, 0.18);
        backdrop-filter: blur(10px);
        display: grid;
        gap: 10px;
      }
      .floating-time-row {
        display: grid;
        grid-template-columns: 80px 1fr;
        align-items: baseline;
        column-gap: 5px;
        font-variant-numeric: tabular-nums;
      }
      .floating-time-label { color: var(--muted); font-weight: 900; font-size: 13px; white-space: nowrap; }
      .floating-time-value { font-weight: 950; font-size: 20px; letter-spacing: 0.2px; text-align: right; }
      .floating-time-value b { font-size: 22px; }
      .exam-time-item {
        display: inline-flex;
        align-items: baseline;
        gap: 10px;
        font-weight: 950;
        font-variant-numeric: tabular-nums;
      }
      .exam-time-label { color: var(--muted); font-weight: 850; font-size: 13px; }
      .exam-time-value { font-weight: 950; font-size: 18px; }
      .exam-time-value b { font-size: 20px; letter-spacing: 0.2px; }

      @media (max-width: 860px) {
        .floating-time-card {
          left: 18px;
          width: auto;
          transform: none;
        }
      }
      /* Wide screens: stick the card to the exam surface edge (in the left gutter). */
      @media (min-width: 1500px) {
        .floating-time-card {
          left: calc((100vw - 1080px) / 2 - 12px);
          transform: translateX(-100%);
        }
      }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid rgba(15, 23, 42, 0.10);
        background: rgba(255, 255, 255, 0.86);
        font-weight: 800;
        font-size: 12px;
        color: rgba(15, 23, 42, 0.86);
        white-space: nowrap;
      }
    </style>
  </head>
  <body>
    <header class="topbar">
      <div class="container topbar-inner">
        <div class="brand" aria-label="Servforce Quiz">
          <span class="brand-badge" aria-hidden="true"></span>
          <span>Servforce Quiz</span>
        </div>
      </div>
    </header>

    <main class="container exam-frame page">
      {% for m in get_flashed_messages() %}
      <div class="flash error">{{ m }}</div>
      {% endfor %}

      <div class="floating-time-card" role="region" aria-label="时间浮窗">
        <div class="floating-time-row">
          <span class="floating-time-label">剩余时间</span>
          <span class="floating-time-value"><b id="remain" data-seconds="{{ remaining_seconds }}">{{ remaining_seconds }}</b></span>
        </div>
        <div class="floating-time-row">
          <span class="floating-time-label">最小交卷</span>
          <span class="floating-time-value"><b id="minRemain">--:--:--</b></span>
        </div>
      </div>

      <div class="surface exam-surface" role="region" aria-label="试卷">
        <div class="exam-submit-corner" aria-label="提交试卷">
          <form method="post" action="/api/public/submit/{{ token }}" style="margin:0;">
            <button id="submitBtn" class="btn btn-primary" type="submit">提交试卷</button>
          </form>
        </div>

        <section class="section">
          <div class="exam-meta-title">
            <h2>{{ spec.title }}</h2>
            <span class="muted">({{ exam_key }})</span>
          </div>
          {% if spec.description %}
            <div class="exam-meta-desc">{{ spec.description }}</div>
          {% endif %}
          <div class="exam-meta-stats" aria-label="试卷统计">
            <span class="pill">题目数：{{ (exam_stats or {}).get('total_questions', 0) }}</span>
            <span class="pill">总分：{{ (exam_stats or {}).get('total_points', 0) }} 分</span>
            {% for t, c in ((exam_stats or {}).get('counts_by_type', {}) or {}).items() %}
              {% set pts = ((exam_stats or {}).get('points_by_type', {}) or {}).get(t, 0) %}
              <span class="pill">{{ (type_label_map or {}).get(t, t) }}：{{ c }} 题 / {{ pts }} 分</span>
            {% endfor %}
          </div>
        </section>

        <section class="section">
          <form id="examForm">
            <input type="hidden" name="token" value="{{ token }}" />
            {% for q in spec.questions %}
              <div class="exam-q" data-qid="{{ q.qid }}">
                <div class="exam-q__inner">
                  <div class="exam-q__head">
                    <div class="exam-q__head-left">
                      <span class="exam-q__qid">{{ q.label or q.qid }}</span>
                      {% set type_label_map = {'single':'单选','multiple':'多选','short':'简答','unknown':'其他'} %}
                      <span class="exam-tag type">{{ type_label_map.get(q.type, q.type) }}</span>
                    </div>
                    <span class="exam-tag points">{{ q.max_points }}分</span>
                  </div>

                  <div class="exam-q__body">
                    <div class="md">{{ q.stem_md | md }}</div>

                    {% if q.type == 'single' %}
                      <div class="exam-options" aria-label="选项">
                        {% for o in q.options %}
                          <label class="exam-opt">
                            <input type="radio" name="{{ q.qid }}" value="{{ o.key }}" {% if answers.get(q.qid)==o.key %}checked{% endif %} />
                            <div class="exam-opt__box">
                              <div class="exam-opt__key">{{ o.key }}</div>
                              <div class="exam-opt__text">{{ o.text }}</div>
                            </div>
                          </label>
                        {% endfor %}
                      </div>
                    {% elif q.type == 'multiple' %}
                      {% set chosen = answers.get(q.qid) or [] %}
                      <div class="exam-options" aria-label="选项">
                        {% for o in q.options %}
                          <label class="exam-opt">
                            <input type="checkbox" name="{{ q.qid }}[]" value="{{ o.key }}" {% if o.key in chosen %}checked{% endif %} />
                            <div class="exam-opt__box">
                              <div class="exam-opt__key">{{ o.key }}</div>
                              <div class="exam-opt__text">{{ o.text }}</div>
                            </div>
                          </label>
                        {% endfor %}
                      </div>
                    {% else %}
                      <textarea name="{{ q.qid }}" class="exam-short" placeholder="请输入你的回答">{{ answers.get(q.qid) or "" }}</textarea>
                    {% endif %}
                  </div>
                </div>
              </div>
            {% endfor %}
          </form>
        </section>
      </div>
    </main>

    <script>
      const remainEl = document.getElementById('remain');
      let remain = parseInt(remainEl.dataset.seconds || remainEl.textContent || '0', 10);
      const timeLimit = parseInt("{{ time_limit_seconds }}", 10) || 0;
      const minSubmit = parseInt("{{ min_submit_seconds }}", 10) || 0;

      const submitBtn = document.getElementById('submitBtn');
      const submitHint = document.getElementById('submitHint');
      const minRemainEl = document.getElementById('minRemain');

      function pad2(n) { return String(n).padStart(2, '0'); }
      function formatSeconds(s) {
        const sec = Math.max(0, parseInt(s || '0', 10));
        const h = Math.floor(sec / 3600);
        const m = Math.floor((sec % 3600) / 60);
        const r = sec % 60;
        return `${pad2(h)}:${pad2(m)}:${pad2(r)}`;
      }

      function updateRemain() {
        remainEl.textContent = formatSeconds(remain);
      }

      function updateMinRemain() {
        if (!minRemainEl) return;
        const elapsed = timeLimit ? Math.max(0, timeLimit - remain) : 0;
        const left = Math.max(0, minSubmit - elapsed);
        minRemainEl.textContent = formatSeconds(left);
      }

      function updateSubmitState() {
        if (!submitBtn) return;
        const elapsed = timeLimit ? Math.max(0, timeLimit - remain) : 0;
        const canSubmit = minSubmit <= 0 || remain <= 0 || elapsed >= minSubmit;
        submitBtn.disabled = !canSubmit;
        updateMinRemain();
        if (!submitHint) return;
        if (canSubmit) {
          submitHint.textContent = '';
          return;
        }
        const wait = Math.max(0, minSubmit - elapsed);
        submitHint.textContent = `还需等待 ${formatSeconds(wait)} 才可交卷`;
      }

      updateRemain();
      updateMinRemain();
      updateSubmitState();

      setInterval(() => {
        if (remain <= 0) return;
        remain -= 1;
        updateRemain();
        updateSubmitState();
        if (remain === 0) {
          const f = document.querySelector('form[action^="/api/public/submit"]');
          if (!f) return;
          if (typeof f.requestSubmit === 'function') {
            f.requestSubmit();
          } else if (submitBtn) {
            submitBtn.click();
          } else {
            f.submit();
          }
        }
      }, 1000);

      function saveAnswer(formData, token, qid) {
        formData.append('question_id', qid);
        fetch(`/api/public/answers/${token}`, { method: 'POST', body: formData }).catch(() => {});
      }

      function collectAnswerForQBox(qBox) {
        const qid = qBox.dataset.qid;
        const fd = new FormData();
        const textarea = qBox.querySelector('textarea');
        const radios = qBox.querySelectorAll('input[type="radio"]');
        const checks = qBox.querySelectorAll('input[type="checkbox"]');
        if (checks && checks.length) {
          const checked = qBox.querySelectorAll('input[type="checkbox"]:checked');
          checked.forEach(x => fd.append('answer[]', x.value));
        } else if (radios && radios.length) {
          const chosen = qBox.querySelector('input[type="radio"]:checked');
          if (chosen) fd.append('answer', chosen.value);
        } else if (textarea) {
          fd.append('answer', textarea.value || '');
        }
        return { qid, fd };
      }

      const examFormEl = document.getElementById('examForm');

      examFormEl.addEventListener('change', (e) => {
        const qBox = e.target.closest('.exam-q');
        if (!qBox) return;
        const token = "{{ token }}";
        const { qid, fd } = collectAnswerForQBox(qBox);
        saveAnswer(fd, token, qid);
      });

      // Also auto-save textarea while typing (avoid losing content when user submits too early).
      const debounceByQid = new Map();
      examFormEl.addEventListener('input', (e) => {
        if (!e.target || e.target.tagName !== 'TEXTAREA') return;
        const qBox = e.target.closest('.exam-q');
        if (!qBox) return;
        const token = "{{ token }}";
        const { qid } = collectAnswerForQBox(qBox);
        const prev = debounceByQid.get(qid);
        if (prev) clearTimeout(prev);
        const t = setTimeout(() => {
          const { fd } = collectAnswerForQBox(qBox);
          saveAnswer(fd, token, qid);
        }, 350);
        debounceByQid.set(qid, t);
      });

      function collectAllAnswersObject() {
        const qBoxes = Array.from(document.querySelectorAll('.exam-q[data-qid]'));
        const out = {};
        for (const qBox of qBoxes) {
          const qid = qBox.dataset.qid;
          const textarea = qBox.querySelector('textarea');
          const radios = qBox.querySelectorAll('input[type="radio"]');
          const checks = qBox.querySelectorAll('input[type="checkbox"]');
          if (checks && checks.length) {
            const checked = Array.from(qBox.querySelectorAll('input[type="checkbox"]:checked')).map(x => x.value);
            if (checked.length) out[qid] = checked;
          } else if (radios && radios.length) {
            const chosen = qBox.querySelector('input[type="radio"]:checked');
            if (chosen) out[qid] = chosen.value;
          } else if (textarea) {
            const v = textarea.value || '';
            if (v.trim() !== '') out[qid] = v;
          }
        }
        return out;
      }

      async function saveAllAnswersBulk() {
        const token = "{{ token }}";
        const answers = collectAllAnswersObject();
        try {
          await fetch(`/api/public/answers_bulk/${token}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ answers }),
          });
        } catch (_e) {}
      }

      const submitForm = document.querySelector('form[action^="/api/public/submit"]');
      let submitting = false;
      if (submitForm) {
        submitForm.addEventListener('submit', async (e) => {
          if (submitting) return;
          e.preventDefault();

          // Not reached min submit time: only show hint, do not refresh, keep answers.
          const elapsed = timeLimit ? Math.max(0, timeLimit - remain) : 0;
          const canSubmit = minSubmit <= 0 || remain <= 0 || elapsed >= minSubmit;
          if (!canSubmit) {
            updateSubmitState();
            return;
          }

          // Ensure latest answers are persisted before submitting.
          submitting = true;
          try {
            await saveAllAnswersBulk();
          } finally {
            // Use native submit() to bypass this handler.
            submitForm.submit();
          }
        });
      }
    </script>
  </body>
</html>
